# Fireside Reviews
Fireside Reviews is a role-based performance review system built with **Next.js (App Router)** and **Supabase**.

It supports structured review cycles, **job-familyâ€“specific performance standards**, controlled visibility of ratings, and admin-managed workflows, with business rules enforced **in Postgres**, not the frontend.

This project is developed **locally-first**, with Supabase as the system of record.

---

## ğŸ¯ Project Goal
Build a flexible, auditable performance review platform where:

- Performance standards are defined **per job family**
- All employees in a job family are evaluated against the **same rubric**
- Admins can manage job families, review forms, and assignments **without code changes**
- Review visibility is enforced **at the database layer (RLS + triggers + functions)**
- The frontend can evolve or be replaced without rewriting backend logic

---

## ğŸ§  Core Concepts (Read This First)

### Job Families (aka Job Roles)

Job families are **fully data-driven**.

**Table:** `job_roles`

| column | type | notes |
|------|------|------|
| id | uuid | PK, default `gen_random_uuid()` |
| code | text | UNIQUE, canonical identifier |
| name | text | Display name |
| employee_code_prefix | text | Prefix for employee codes (e.g. `DRV`, `TEC`) |
| is_default_employee | boolean | Used for auto-creation |
| is_default_admin | boolean | Used for admin profiles |

Key rules:

- `job_roles.id` is the **only** thing referenced by other tables
- `code` is a stable human-readable identifier
- **No enums** or hardcoded job families anywhere
- Admins can add / rename job families at runtime

Admin UI: `/admin/job-families`

---

### System Roles (Different Thing)

System roles control **access**, not performance standards:

- `admin`
- `reviewer`
- `employee`

A backoffice employee may or may not be a system admin.

System roles are enforced via:
- `admin_users`
- RLS
- API guards (`requireAdmin`)

---

## ğŸ†” Employee Codes (Invariant)

Employee codes are:

- Generated **only in the database**
- Never editable from UI or API
- Stable for the lifetime of an employee

### How codes are generated

- Function: `generate_employee_code(job_role_id uuid)`
- Trigger: `set_employee_code()` on `employees`
- Backed by table: `employee_code_counters`

**Important notes (education / debugging):**
- `employee_code_counters` is keyed by `job_role_id`
- Old legacy code paths referencing `role` or job role *codes* were removed
- Prefix comes from `job_roles.employee_code_prefix`
- Default prefix fallback is `EMP` (legacy safety)

âš ï¸ If employee codes look wrong in prod, the issue is **always** in DB functions or triggers, not frontend state.

---

## ğŸ‘¥ Profiles vs Employees (Critical Distinction)

### `profiles`
- Mirrors `auth.users`
- Stores identity fields (e.g. `full_name`, `email`)
- Strict RLS:
  - User can see self
  - Admin can see all

### `employees`
- Stores employment metadata:
  - `job_role_id`
  - `hire_date`
  - `employee_code`
- **Does NOT store names or emails**

Admin UI joins these tables but must respect RLS.

### Invites & Employee Upsert

Invites are handled via:
`POST /api/admin/invite-user`

Flow:
1. Admin validation (`requireAdmin`)
2. Supabase Auth invite
3. `profiles` upsert
4. `employees` upsert via `upsert_employee(uuid, uuid, date)`
5. Employee code generated by trigger

Job family validation is **dynamic** (checked against `job_roles`).

---

## ğŸ“ Review Model (Current Schema)

### Review Requirements

For a performance report to be finalized:

- **Self review** must be submitted
- **Primary review** must be submitted
- Peer / secondary reviews are optional (unless configured later)

Enforced by:
`assert_minimum_reviews_submitted(cycle_id, employee_id)`

---

### Narrative Storage (Current State)

Narratives are split by visibility and stored in `reviews`:

- `summary_reviewer_private`
  - Visible to reviewer + admin only
- `summary_employee_visible`
  - Visible to employee after release
- `status`
  - `draft`
  - `submitted`
  - `finalized`

There is **no generic narrative column**.

---

### Scoring Rules (Current State)

**Current DB behavior:**
- Only **PRIMARY** reviews may have scores in `review_scores`
- Enforced by trigger `trg_primary_only_scores`
- Self, peer, and secondary reviews are narrative-only **today**

**Future direction (already scaffolded):**
- `reviewer_rules` exists with `is_required` and `is_scored`
- Trigger currently hard-blocks non-primary scoring
- When configurable scoring is implemented, enforcement should consult `reviewer_rules` (likely cycle-aware)

---

## ğŸ§® Finalization Logic (Authoritative)

Finalization is handled entirely in SQL:

`finalize_employee_cycle_summary(
  p_cycle_id uuid,
  p_employee_id uuid,
  p_final_narrative text,
  p_calibration_adjustment integer,
  p_calibration_reason text,
  p_computed_by uuid
)`

Key guarantees:
- Uses `employees.job_role_id` (UUID) only
- Looks up rubric via `cycle_rubrics`
- No references to deprecated columns
- All validation and score computation happens server-side

Outputs:
- `cycle_employee_summary` (admin-visible)
- `cycle_employee_summary_public` (employee-safe)

---

## ğŸ‘€ Visibility Rules (Non-Negotiable)

Enforced via **Postgres RLS + triggers**, never frontend logic.

| Viewer | Can See |
|------|--------|
| Primary reviewer | Scores + narratives (as permitted) |
| Secondary / Peer | Narrative-only (current default) |
| Employee | Employee-visible narrative + rating |
| Admin | Everything |

Raw scores and calibrations are never exposed unless explicitly allowed.

---

### Submission Locking (DB-Enforced)

Once `reviews.status = 'submitted'`:
- Reviewer narratives are immutable
- Scores are immutable
- Enforcement is handled via Postgres triggers
- UI controls are advisory only

Admins may override by reopening a review (future admin-only function).

---

## ğŸ—„ï¸ Database Model (High Level)

### Core Tables
- `profiles`
- `admin_users`
- `job_roles`
- `employees`
- `review_cycles`
- `rubrics`
- `cycle_rubrics`
- `review_assignments`
- `reviews`
- `review_scores`
- `cycle_employee_summary`
- `cycle_employee_summary_public`
- `audit_log`

### Core Tables by Domain (for navigation)
This section **groups the same tables above** by function. It does not replace the Core Tables list.

**Identity & access**
- `profiles`
- `admin_users`
- (Supabase Auth: `auth.users` is external)

**Org structure**
- `job_roles`
- `employees`

**Cycles & assignments**
- `review_cycles`
- `review_assignments`

**Reviews & scoring**
- `reviews`
- `review_scores`

**Rubrics**
- `rubrics`
- `cycle_rubrics`
- `rubric_categories`
- `rubric_questions`

**Cycle rollups**
- `cycle_employee_summary`
- `cycle_employee_summary_public`

**Audit**
- `audit_log`

---

## ğŸ§± Architecture Overview

### Frontend
- Next.js App Router
- Client components for admin & reviewer UI
- API routes for privileged operations
- UI intentionally minimal and non-authoritative

### Backend
- Supabase Postgres is the source of truth
- Business rules live in:
  - SQL functions
  - Triggers
  - RLS policies

---

## ğŸ” Authentication & Supabase Clients

Two Supabase clients are **intentional and required**.

### 1ï¸âƒ£ Server client â€” `lib/supabaseServer.ts`

Used in:
- Server Components
- Route Handlers (`app/api/**`)
- Server Actions

Includes a required cookie write guard to avoid Next.js App Router errors.

### 2ï¸âƒ£ Browser client â€” `lib/supabaseClient.ts`

Used in:
- `"use client"` components only
- Browser-side reads and future realtime usage

---

## ğŸ§© Review Flow (Simplified)

1. Admin creates a review cycle
2. Admin assigns:
   - Job families â†’ rubrics
   - Employees â†’ job families
3. Review assignments are generated
4. Reviewers submit narratives
5. Primary reviewer submits scores
6. Admin finalizes calibration
7. Employee sees finalized summary

---

## ğŸ“‚ Repo Structure
app/
â”œâ”€â”€ admin/
â”‚ â”œâ”€â”€ employees/
â”‚ â”œâ”€â”€ job-families/
â”‚ â”œâ”€â”€ assignments/
â”‚ â””â”€â”€ cycles/
â”œâ”€â”€ reviews/
â”‚ â”œâ”€â”€ page.tsx
â”‚ â””â”€â”€ [assignmentId]/
â”‚ â”œâ”€â”€ page.tsx
â”‚ â””â”€â”€ review-form.tsx
â”œâ”€â”€ api/
â”‚ â”œâ”€â”€ admin/
â”‚ â””â”€â”€ reviews/
lib/
â”œâ”€â”€ supabaseServer.ts
â”œâ”€â”€ supabaseClient.ts
â”œâ”€â”€ requireAdmin.ts
â”œâ”€â”€ me.ts
â””â”€â”€ meServer.ts
supabase/
â”œâ”€â”€ migrations/
â”œâ”€â”€ schema.sql
â””â”€â”€ seed.sql

yaml

---

## ğŸ§ª Local Development Notes

- Supabase CLI is used for migrations
- `schema.sql` is a read-only snapshot
- SQL Editor bypasses RLS; UI does not
- All DB changes must be incremental migrations

---

## âš ï¸ What Can Break in Prod

1. Missing `employee_code_prefix` in new job roles
2. RLS blocking admin reads on `profiles`
3. Rubric category mismatch vs submitted scores
4. Reintroduction of legacy DB functions
5. Forgetting to regenerate `schema.sql`

---

## ğŸš« Things You Should Never Change Without a Migration (DB Invariants)

This project treats **Supabase Postgres as the source of truth**. Any change to tables, constraints, triggers, functions, enums, or RLS policies must be done via an **incremental migration** (never ad-hoc in the SQL editor).

### 1) Primary keys, foreign keys, and relationship columns
Do not change or drop these without a migration:
- Any table `id` column defaults (e.g., `gen_random_uuid()`)
- Foreign key columns like:
  - `employees.job_role_id`
  - `review_assignments.cycle_id`, `review_assignments.employee_id`, `review_assignments.reviewer_id`
  - `reviews.assignment_id`, `reviews.cycle_id`, `reviews.employee_id`, `reviews.reviewer_id`
  - `review_scores.review_id`
  - `cycle_rubrics.cycle_id`, `cycle_rubrics.rubric_id` (and `job_role_id` if used)

If you change FK relationships, PostgREST nested selects and RLS assumptions will break.

---

### 2) RLS policies (and anything that affects visibility)
Never â€œquick editâ€ RLS in production:
- `profiles` policies (admin reads + self reads)
- reviewer visibility policies for:
  - `review_assignments`
  - `reviews`
  - `review_scores`
- employee visibility policies for:
  - `cycle_employee_summary_public`
  - employee-safe narrative fields

RLS is part of the appâ€™s security model. Changes must be reviewed, migrated, and tested.

---

### 3) Triggers and functions that enforce invariants
These are core business rules and must only be changed in migrations:

**Employee codes**
- `generate_employee_code(job_role_id uuid)`
- `set_employee_code()` trigger on `employees`
- `employee_code_counters` behavior

**Review requirements and finalization**
- `assert_minimum_reviews_submitted(cycle_id, employee_id)`
- `finalize_employee_cycle_summary(...)`

**Scoring enforcement**
- `trg_primary_only_scores` / enforcement function that prevents non-primary scoring (until reviewer_rules is wired)

If any of these break, the UI may still appear to work but the database will become inconsistent.

---

### 4) Review status model (workflow semantics)
Do not change these without a migration and corresponding backend enforcement updates:
- `reviews.status` enum values (e.g., `draft`, `submitted`, `finalized`)
- `submitted_at` / `finalized_at` expectations
- Any logic that assumes â€œsubmitted reviews are immutableâ€ (submission locking)

The workflow semantics are used across API routes, SQL logic, and reporting tables.

---

### 5) Rubric structure and how scoring keys are derived
Never change rubric tables casually:
- `rubrics`
- `cycle_rubrics`
- `rubric_categories`
- `rubric_questions`

Also: be careful with any column that determines how `review_scores.category_scores` keys are created:
- If you use `rubric_categories.code` or similar as keys, changing those values can orphan historical scores.
- If you switch from `code`-keys to `id`-keys, do it with a migration and backfill plan.

---

### 6) Audit & summary tables
These tables reflect downstream derived state:
- `cycle_employee_summary`
- `cycle_employee_summary_public`
- `audit_log`

Any schema changes require updating the SQL that writes to them (especially finalization logic).

---

### 7) PostgREST expectations (nested selects)
If you remove or change foreign keys, nested selects will fail with errors like `PGRST200`.
Known dependency chains:
- `review_assignments` â†’ `reviews` (by FK on `reviews.assignment_id`)
- `reviews` â†’ `review_scores` (by FK on `review_scores.review_id`)

Breaking these breaks the reviewer UI and server queries.

---

### 8) Anything referenced by the frontend or API contracts
These fields are part of an implicit contract:
- `reviews.summary_reviewer_private`
- `reviews.summary_employee_visible`
- `reviews.status`
- `review_scores.category_scores`
- `review_assignments.reviewer_type`

If you rename/remove these without a migration + code updates, the UI and API routes will fail.

---

### 9) Never treat the SQL editor as a â€œdeployment mechanismâ€
- SQL Editor is fine for exploration.
- Do not apply production changes there.
- Migrations must be the only source of schema evolution.

---

### 10) Always regenerate schema.sql after schema changes
`schema.sql` is a snapshot used for debugging and sharing context.
After applying migrations:
`bash`
npx supabase db dump --schema public --file schema.sql

---
makefile
::contentReference[oaicite:0]{index=0}

---

## ğŸ§­ Roadmap (Short)

- Finish rubric-driven scoring UI
- Enforce submission locking in SQL
- Wire `reviewer_rules` into scoring enforcement
- Build employee-facing summary view

---

## Status

ğŸš§ Active development  
Schema stable, admin flows working, reviewer flow in progress



